/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ReminderFocusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var translations = {
  en: {
    focusInterval: "Minimum focus interval (seconds)",
    focusIntervalDesc: "Minimum time between two consecutive window focus actions",
    detectionInterval: "Detection interval (milliseconds)",
    detectionIntervalDesc: "How often to check for reminder modals (lower values = more responsive, higher CPU usage)",
    language: "Language",
    languageDesc: "Select display language for this plugin",
    debugMode: "Debug mode",
    debugModeDesc: "Enable detailed logging for troubleshooting (for developers)",
    auto: "Auto",
    chinese: "\u4E2D\u6587",
    english: "English",
    reminderDetected: "Reminder detected, focusing window",
    focusSkipped: "Window already active, skipping focus",
    focusCooldown: "Focus on cooldown, skipping",
    settingsSaved: "Settings saved successfully",
    invalidInterval: "Please enter a valid number for focus interval (1 second or higher)",
    invalidDetectionInterval: "Please enter a valid number for detection interval (100ms or higher)"
  },
  zh: {
    focusInterval: "\u6700\u5C0F\u805A\u7126\u95F4\u9694\uFF08\u79D2\uFF09",
    focusIntervalDesc: "\u4E24\u6B21\u7A97\u53E3\u7F6E\u9876\u4E4B\u95F4\u7684\u6700\u5C0F\u65F6\u95F4\u95F4\u9694",
    detectionInterval: "\u68C0\u6D4B\u95F4\u9694\uFF08\u6BEB\u79D2\uFF09",
    detectionIntervalDesc: "\u68C0\u6D4B\u63D0\u9192\u5F39\u7A97\u7684\u9891\u7387\uFF08\u6570\u503C\u8D8A\u5C0F\u54CD\u5E94\u8D8A\u5FEB\uFF0C\u4F46CPU\u5360\u7528\u8D8A\u9AD8\uFF09",
    language: "\u8BED\u8A00",
    languageDesc: "\u9009\u62E9\u63D2\u4EF6\u7684\u663E\u793A\u8BED\u8A00",
    debugMode: "\u8C03\u8BD5\u6A21\u5F0F",
    debugModeDesc: "\u542F\u7528\u8BE6\u7EC6\u65E5\u5FD7\u8BB0\u5F55\u7528\u4E8E\u6545\u969C\u6392\u9664\uFF08\u4F9B\u5F00\u53D1\u8005\u4F7F\u7528\uFF09",
    auto: "\u81EA\u52A8",
    chinese: "\u4E2D\u6587",
    english: "English",
    reminderDetected: "\u68C0\u6D4B\u5230\u63D0\u9192\uFF0C\u6B63\u5728\u7F6E\u9876\u7A97\u53E3",
    focusSkipped: "\u7A97\u53E3\u5DF2\u5904\u4E8E\u6D3B\u52A8\u72B6\u6001\uFF0C\u8DF3\u8FC7\u7F6E\u9876",
    focusCooldown: "\u805A\u7126\u51B7\u5374\u4E2D\uFF0C\u8DF3\u8FC7\u7F6E\u9876",
    settingsSaved: "\u8BBE\u7F6E\u5DF2\u6210\u529F\u4FDD\u5B58",
    invalidInterval: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u805A\u7126\u95F4\u9694\u6570\u5B57\uFF081\u79D2\u6216\u66F4\u9AD8\uFF09",
    invalidDetectionInterval: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u68C0\u6D4B\u95F4\u9694\u6570\u5B57\uFF08100\u6BEB\u79D2\u6216\u66F4\u9AD8\uFF09"
  }
};
var DEFAULT_SETTINGS = {
  focusInterval: 10,
  detectionInterval: 5e3,
  // 默认每5秒检测一次
  language: "auto",
  debugMode: false
  // 默认关闭调试模式
};
var ReminderFocusPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.lastFocusTime = 0;
    this.focusedModals = /* @__PURE__ */ new Set();
    this.modalObserver = null;
    this.detectionTimer = null;
  }
  // Debug logging method
  debug(message, ...args) {
    if (this.settings?.debugMode) {
      console.debug(`[Reminder Focus] ${message}`, ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    this.updateTranslations();
    this.debug("Plugin loaded");
    this.addSettingTab(new ReminderFocusSettingTab(this.app, this));
    this.setupModalDetection();
  }
  onunload() {
    this.debug("Plugin unloaded");
    this.cleanup();
  }
  cleanup() {
    if (this.modalObserver) {
      this.modalObserver.disconnect();
      this.modalObserver = null;
    }
    if (this.detectionTimer) {
      window.clearInterval(this.detectionTimer);
      this.detectionTimer = null;
    }
    this.focusedModals.clear();
    this.lastFocusTime = 0;
  }
  setupModalDetection() {
    this.modalObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.addedNodes.length > 0) {
          for (let i = 0; i < mutation.addedNodes.length; i++) {
            const node = mutation.addedNodes[i];
            if (node instanceof HTMLElement) {
              if (node.classList.contains("modal-container") || node.querySelector(".modal-container")) {
                this.checkForReminderModal(node);
              }
            }
          }
        }
      }
    });
    this.modalObserver.observe(document.body, {
      childList: true,
      subtree: true
      // 需要 subtree 因为 modal-container 可能不是直接子元素
    });
    this.detectionTimer = window.setInterval(() => {
      this.checkAllModals();
    }, this.settings.detectionInterval);
    this.registerInterval(this.detectionTimer);
    this.registerEvent(
      this.app.workspace.on("window-open", () => {
        setTimeout(() => {
          this.checkAllModals();
        }, 100);
      })
    );
    this.checkAllModals();
  }
  checkForReminderModal(element) {
    if (element.classList.contains("modal-container")) {
      if (this.isObsidianReminderModal(element)) {
        this.debug("Detected reminder modal (direct)");
        this.handleReminderModal(element);
      }
    } else {
      const modal = element.querySelector(".modal-container");
      if (modal && this.isObsidianReminderModal(modal)) {
        this.debug("Detected reminder modal (child)");
        this.handleReminderModal(modal);
      }
    }
  }
  checkAllModals() {
    const modals = document.querySelectorAll(".modal-container");
    for (let i = 0; i < modals.length; i++) {
      this.checkForReminderModal(modals[i]);
    }
  }
  handleReminderModal(modalElement) {
    const modalId = this.getModalId(modalElement);
    if (this.focusedModals.has(modalId)) {
      return;
    }
    this.focusedModals.add(modalId);
    this.debug(`Processing modal: ${modalId}`);
    const observer = new MutationObserver(() => {
      if (!document.body.contains(modalElement)) {
        this.debug(`Modal ${modalId} closed, removing from focused set`);
        this.focusedModals.delete(modalId);
        observer.disconnect();
      }
    });
    observer.observe(modalElement.parentElement || document.body, {
      childList: true,
      subtree: true
    });
    void this.focusModal(modalElement, modalId);
  }
  getModalId(element) {
    if (element.id) {
      return element.id;
    }
    if (element.dataset.modalId) {
      return element.dataset.modalId;
    }
    const textContent = element.textContent?.substring(0, 100) || "";
    const className = element.className || "";
    const tagStructure = this.getElementStructure(element);
    const contentHash = this.simpleHash(textContent + className + tagStructure);
    const modalId = `reminder-modal-${contentHash}`;
    element.dataset.modalId = modalId;
    return modalId;
  }
  getElementStructure(element) {
    const tagName = element.tagName.toLowerCase();
    const attributeInfo = Array.from(element.attributes).slice(0, 5).map((attr) => `${attr.name}="${attr.value.substring(0, 20)}"`).join(" ");
    const childTags = Array.from(element.children).slice(0, 5).map((child) => child.tagName.toLowerCase()).join(",");
    return `${tagName}[${attributeInfo}]>{${childTags}}`;
  }
  hasButtonWithText(element, text) {
    const buttons = element.querySelectorAll("button");
    for (let i = 0; i < buttons.length; i++) {
      const button = buttons[i];
      if (button.textContent?.includes(text)) {
        return true;
      }
    }
    return false;
  }
  isObsidianReminderModal(element) {
    const textContent = element.textContent || "";
    const buttons = element.querySelectorAll("button");
    if (buttons.length === 0) {
      return false;
    }
    const hasSnoozeButton = this.hasButtonWithText(element, "Snooze");
    const hasDoneButton = this.hasButtonWithText(element, "Done");
    if (hasDoneButton && hasSnoozeButton) {
      this.debug("Detected reminder modal: has both Done and Snooze buttons");
      return true;
    }
    if (element.querySelector(".reminder-modal, .reminder-title, .reminder-actions, .reminder-file")) {
      this.debug("Detected reminder modal: has reminder CSS classes");
      return true;
    }
    const hasReminderStructure = element.querySelector("h3") !== null && // reminder-title 使用 h3
    element.querySelector("select") !== null && // Snooze 下拉选择
    element.querySelector("select option[selected][disabled][hidden]") !== null;
    if (hasReminderStructure && (hasSnoozeButton || hasDoneButton)) {
      this.debug("Detected reminder modal: has reminder structure and buttons");
      return true;
    }
    if (element.querySelector('button[aria-label*="reminder"]') || element.querySelector('[aria-label*="Remind me later"]') || element.querySelector('[aria-label*="Mark as Done"]') || element.querySelector('button[aria-label*="Done"]')) {
      this.debug("Detected reminder modal: has reminder aria-labels");
      return true;
    }
    const hasSpecificButtonCombination = (hasSnoozeButton || textContent.includes("Snooze")) && (hasDoneButton || textContent.includes("Done")) && (textContent.includes("minutes") || textContent.includes("hours") || textContent.includes("Tomorrow") || textContent.includes("Next week"));
    if (hasSpecificButtonCombination) {
      this.debug("Detected reminder modal: has specific button combination and time options");
      return true;
    }
    if (element.querySelector(".mod-cta") && element.querySelector("select.dropdown") && (hasSnoozeButton || hasDoneButton)) {
      this.debug("Detected reminder modal: has NotificationModal features");
      return true;
    }
    if (element.querySelector(".reminder-file") || element.querySelector('button[aria-label*=".md"]') || textContent.includes(".md") && (hasSnoozeButton || hasDoneButton)) {
      this.debug("Detected reminder modal: has file link");
      return true;
    }
    if ((element.querySelector("[data-svelte]") || element.classList.toString().includes("svelte")) && (hasSnoozeButton || hasDoneButton)) {
      this.debug("Detected reminder modal: has Svelte features");
      return true;
    }
    if ((textContent.includes("reminder") || textContent.includes("\u63D0\u9192")) && (hasSnoozeButton || hasDoneButton) && textContent.length < 2e3) {
      this.debug("Detected reminder modal: has basic reminder indicators");
      return true;
    }
    return false;
  }
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  async focusModal(modalElement, modalId) {
    const now = Date.now();
    const timeSinceLastFocus = (now - this.lastFocusTime) / 1e3;
    if (timeSinceLastFocus < this.settings.focusInterval) {
      this.debug(this.t("focusCooldown") + ` (Modal: ${modalId})`);
      return;
    }
    this.lastFocusTime = now;
    try {
      await this.ensureWindowVisible();
      await this.delay(150);
      this.focusModalElement(modalElement);
      this.debug(this.t("reminderDetected") + ` (Modal: ${modalId})`);
    } catch (error) {
      console.error("Failed to focus modal:", error, `(Modal: ${modalId})`);
    }
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async ensureWindowVisible() {
    return new Promise((resolve) => {
      window.focus();
      this.tryElectronFocus().then(() => resolve()).catch((err) => {
        this.debug("Electron focus failed, falling back to standard focus", err);
        resolve();
      });
    });
  }
  async tryElectronFocus() {
    const electronWindow = window;
    if (!electronWindow.require) {
      return;
    }
    try {
      const electron = electronWindow.require("electron");
      const remote = electron?.remote;
      if (!remote) {
        this.debug("Electron remote not available");
        return;
      }
      const currentWindow = remote.getCurrentWindow();
      if (!currentWindow) {
        return;
      }
      let needsActivation = false;
      if (currentWindow.isMinimized()) {
        currentWindow.restore();
        this.debug("Window restored from minimized state");
        needsActivation = true;
      }
      if (!currentWindow.isVisible()) {
        currentWindow.show();
        this.debug("Window made visible");
        needsActivation = true;
      }
      if (!currentWindow.isFocused()) {
        this.debug("Window is not focused, bringing to front");
        needsActivation = true;
      }
      if (needsActivation) {
        if (!currentWindow.isAlwaysOnTop()) {
          currentWindow.setAlwaysOnTop(true);
          await this.delay(200);
          currentWindow.setAlwaysOnTop(false);
          currentWindow.focus();
        } else {
          currentWindow.focus();
          await this.delay(100);
        }
      }
    } catch (error) {
      this.debug("Error in tryElectronFocus:", error);
    }
  }
  focusModalElement(modalElement) {
    if (!modalElement.hasAttribute("tabindex")) {
      modalElement.setAttribute("tabindex", "-1");
    }
    void this.focusWithRetry(modalElement, 3);
    this.debug("Focusing modal container");
    modalElement.scrollIntoView({ behavior: "smooth", block: "center" });
  }
  async focusWithRetry(element, maxRetries) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        element.focus();
        if (document.activeElement === element) {
          this.debug(`Focus successful on attempt ${i + 1}`);
          return;
        }
        if (i < maxRetries - 1) {
          await this.delay(50);
        }
      } catch (error) {
        this.debug(`Focus attempt ${i + 1} error:`, error);
        if (i < maxRetries - 1) {
          await this.delay(50);
        }
      }
    }
    this.debug(`Failed to focus element after ${maxRetries} attempts`);
  }
  updateTranslations() {
    const lang = this.getLanguage();
    this.t = (key) => {
      return translations[lang][key] || translations["en"][key] || key;
    };
  }
  getLanguage() {
    if (this.settings.language === "zh") return "zh";
    if (this.settings.language === "en") return "en";
    const obsidianApp = this.app;
    const obsidianLang = obsidianApp.vault?.config?.language;
    const systemLang = navigator.language.toLowerCase();
    if (obsidianLang?.includes("zh") || systemLang.includes("zh")) {
      return "zh";
    }
    return "en";
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateTranslations();
  }
  restartDetection() {
    if (this.modalObserver) {
      this.modalObserver.disconnect();
      this.modalObserver = null;
    }
    if (this.detectionTimer) {
      window.clearInterval(this.detectionTimer);
      this.detectionTimer = null;
    }
    this.setupModalDetection();
  }
};
var ReminderFocusSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("language")).setDesc(this.plugin.t("languageDesc")).addDropdown(
      (dropdown) => dropdown.addOption("auto", this.plugin.t("auto")).addOption("zh", this.plugin.t("chinese")).addOption("en", this.plugin.t("english")).setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian.Notice(this.plugin.t("settingsSaved"));
      })
    );
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("focusInterval")).setDesc(this.plugin.t("focusIntervalDesc")).addText((text) => {
      text.setPlaceholder("10").setValue(String(this.plugin.settings.focusInterval)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 1) {
          this.plugin.settings.focusInterval = num;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian.Notice(this.plugin.t("invalidInterval"));
        }
      });
      const input = text.inputEl;
      input.type = "number";
      input.min = "1";
      input.step = "1";
    });
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("detectionInterval")).setDesc(this.plugin.t("detectionIntervalDesc")).addText((text) => {
      text.setPlaceholder("5000").setValue(String(this.plugin.settings.detectionInterval)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 100) {
          this.plugin.settings.detectionInterval = num;
          await this.plugin.saveSettings();
          this.plugin.restartDetection();
        } else {
          new import_obsidian.Notice(this.plugin.t("invalidDetectionInterval"));
        }
      });
      const input = text.inputEl;
      input.type = "number";
      input.min = "100";
      input.step = "100";
    });
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("debugMode")).setDesc(this.plugin.t("debugModeDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
