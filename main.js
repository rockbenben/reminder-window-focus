/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ReminderFocusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var translations = {
  en: {
    pluginName: "Reminder Window Focus",
    enableFocus: "Enable window focus on reminder",
    enableFocusDesc: "Automatically focus and bring Obsidian to front when reminder appears",
    focusInterval: "Minimum focus interval (seconds)",
    focusIntervalDesc: "Minimum time between two consecutive window focus actions",
    detectionInterval: "Detection interval (milliseconds)",
    detectionIntervalDesc: "How often to check for reminder modals (lower values = more responsive, higher CPU usage)",
    language: "Language",
    languageDesc: "Select display language for this plugin",
    debugMode: "Debug mode",
    debugModeDesc: "Enable detailed logging for troubleshooting (for developers)",
    auto: "Auto",
    chinese: "\u4E2D\u6587",
    english: "English",
    reminderDetected: "Reminder detected, focusing window",
    focusSkipped: "Window already active, skipping focus",
    focusCooldown: "Focus on cooldown, skipping",
    settingsSaved: "Settings saved successfully",
    invalidInterval: "Please enter a valid number for focus interval (1 second or higher)",
    invalidDetectionInterval: "Please enter a valid number for detection interval (100ms or higher)"
  },
  zh: {
    pluginName: "\u63D0\u9192\u7A97\u53E3\u7F6E\u9876",
    enableFocus: "\u542F\u7528\u63D0\u9192\u7A97\u53E3\u7F6E\u9876",
    enableFocusDesc: "\u5F53\u68C0\u6D4B\u5230\u63D0\u9192\u5F39\u7A97\u65F6\uFF0C\u81EA\u52A8\u5C06 Obsidian \u7A97\u53E3\u7F6E\u9876\u5E76\u805A\u7126",
    focusInterval: "\u6700\u5C0F\u805A\u7126\u95F4\u9694\uFF08\u79D2\uFF09",
    focusIntervalDesc: "\u4E24\u6B21\u7A97\u53E3\u7F6E\u9876\u4E4B\u95F4\u7684\u6700\u5C0F\u65F6\u95F4\u95F4\u9694",
    detectionInterval: "\u68C0\u6D4B\u95F4\u9694\uFF08\u6BEB\u79D2\uFF09",
    detectionIntervalDesc: "\u68C0\u6D4B\u63D0\u9192\u5F39\u7A97\u7684\u9891\u7387\uFF08\u6570\u503C\u8D8A\u5C0F\u54CD\u5E94\u8D8A\u5FEB\uFF0C\u4F46CPU\u5360\u7528\u8D8A\u9AD8\uFF09",
    language: "\u8BED\u8A00",
    languageDesc: "\u9009\u62E9\u63D2\u4EF6\u7684\u663E\u793A\u8BED\u8A00",
    debugMode: "\u8C03\u8BD5\u6A21\u5F0F",
    debugModeDesc: "\u542F\u7528\u8BE6\u7EC6\u65E5\u5FD7\u8BB0\u5F55\u7528\u4E8E\u6545\u969C\u6392\u9664\uFF08\u4F9B\u5F00\u53D1\u8005\u4F7F\u7528\uFF09",
    auto: "\u81EA\u52A8",
    chinese: "\u4E2D\u6587",
    english: "English",
    reminderDetected: "\u68C0\u6D4B\u5230\u63D0\u9192\uFF0C\u6B63\u5728\u7F6E\u9876\u7A97\u53E3",
    focusSkipped: "\u7A97\u53E3\u5DF2\u5904\u4E8E\u6D3B\u52A8\u72B6\u6001\uFF0C\u8DF3\u8FC7\u7F6E\u9876",
    focusCooldown: "\u805A\u7126\u51B7\u5374\u4E2D\uFF0C\u8DF3\u8FC7\u7F6E\u9876",
    settingsSaved: "\u8BBE\u7F6E\u5DF2\u6210\u529F\u4FDD\u5B58",
    invalidInterval: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u805A\u7126\u95F4\u9694\u6570\u5B57\uFF081\u79D2\u6216\u66F4\u9AD8\uFF09",
    invalidDetectionInterval: "\u8BF7\u8F93\u5165\u6709\u6548\u7684\u68C0\u6D4B\u95F4\u9694\u6570\u5B57\uFF08100\u6BEB\u79D2\u6216\u66F4\u9AD8\uFF09"
  }
};
var DEFAULT_SETTINGS = {
  enableFocus: true,
  focusInterval: 60,
  detectionInterval: 1e4,
  // 默认每10秒检测一次
  language: "auto",
  debugMode: false
  // 默认关闭调试模式
};
var ReminderFocusPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.lastFocusTime = 0;
    this.focusedModals = /* @__PURE__ */ new Set();
    this.modalObserver = null;
    this.detectionTimer = null;
  }
  // Debug logging method
  debug(message, ...args) {
    if (this.settings?.debugMode) {
      console.log(`[Reminder Focus] ${message}`, ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    this.updateTranslations();
    this.debug("Plugin loaded");
    this.addSettingTab(new ReminderFocusSettingTab(this.app, this));
    this.setupModalDetection();
  }
  onunload() {
    this.debug("Plugin unloaded");
    this.cleanup();
  }
  cleanup() {
    if (this.modalObserver) {
      this.modalObserver.disconnect();
      this.modalObserver = null;
    }
    if (this.detectionTimer) {
      clearInterval(this.detectionTimer);
      this.detectionTimer = null;
    }
    this.focusedModals.clear();
    this.lastFocusTime = 0;
  }
  setupModalDetection() {
    this.modalObserver = new MutationObserver((mutations) => {
      if (!this.settings.enableFocus) return;
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node instanceof HTMLElement) {
            this.checkForReminderModal(node);
          }
        });
      });
    });
    this.modalObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
    this.detectionTimer = window.setInterval(() => {
      if (this.settings.enableFocus) {
        this.checkAllModals();
      }
    }, this.settings.detectionInterval);
    this.registerEvent(
      this.app.workspace.on("window-open", (leaf, win) => {
        if (!this.settings.enableFocus) return;
        setTimeout(() => {
          this.checkAllModals();
        }, 100);
      })
    );
  }
  checkForReminderModal(element) {
    const isReminderModal = element.classList.contains("modal-container") && (element.innerHTML.includes("reminder") || element.innerHTML.includes("\u63D0\u9192") || element.querySelector(".reminder-modal") !== null || element.querySelector("[data-reminder]") !== null || // 检查是否包含 Snooze 按钮（reminder 插件的特征）
    element.innerHTML.includes("Snooze") || element.innerHTML.includes("Done"));
    if (isReminderModal) {
      this.debug("Detected reminder modal");
      this.handleReminderModal(element);
    }
  }
  checkAllModals() {
    const modals = document.querySelectorAll(".modal-container");
    modals.forEach((modal) => {
      if (modal instanceof HTMLElement) {
        this.checkForReminderModal(modal);
      }
    });
  }
  handleReminderModal(modalElement) {
    const modalId = this.getModalId(modalElement);
    if (this.focusedModals.has(modalId)) {
      this.debug(`Modal ${modalId} already focused, skipping`);
      return;
    }
    this.focusedModals.add(modalId);
    this.debug(`Processing modal: ${modalId}`);
    const observer = new MutationObserver(() => {
      if (!document.body.contains(modalElement)) {
        this.debug(`Modal ${modalId} closed, removing from focused set`);
        this.focusedModals.delete(modalId);
        observer.disconnect();
      }
    });
    observer.observe(modalElement.parentElement || document.body, {
      childList: true,
      subtree: true
      // 确保能检测到深层变化
    });
    this.focusModal(modalElement, modalId);
  }
  getModalId(element) {
    if (element.id) {
      return element.id;
    }
    if (element.dataset.modalId) {
      return element.dataset.modalId;
    }
    const textContent = element.textContent?.substring(0, 100) || "";
    const className = element.className || "";
    const innerHTML = element.innerHTML.substring(0, 200);
    const contentHash = this.simpleHash(textContent + className + innerHTML);
    const modalId = `reminder-modal-${contentHash}`;
    element.dataset.modalId = modalId;
    return modalId;
  }
  simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }
  async focusModal(modalElement, modalId) {
    const now = Date.now();
    const timeSinceLastFocus = (now - this.lastFocusTime) / 1e3;
    if (timeSinceLastFocus < this.settings.focusInterval) {
      this.debug(this.t("focusCooldown") + ` (Modal: ${modalId})`);
      return;
    }
    this.lastFocusTime = now;
    try {
      await this.ensureWindowVisible();
      await this.delay(150);
      this.focusModalElement(modalElement);
      this.debug(this.t("reminderDetected") + ` (Modal: ${modalId})`);
    } catch (error) {
      console.error("Failed to focus modal:", error, `(Modal: ${modalId})`);
    }
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async ensureWindowVisible() {
    return new Promise((resolve) => {
      window.focus();
      if (window.require) {
        const { remote } = window.require("electron");
        if (remote) {
          const currentWindow = remote.getCurrentWindow();
          if (currentWindow) {
            let needsActivation = false;
            if (currentWindow.isMinimized()) {
              currentWindow.restore();
              this.debug("Window restored from minimized state");
              needsActivation = true;
            }
            if (!currentWindow.isVisible()) {
              currentWindow.show();
              this.debug("Window made visible");
              needsActivation = true;
            }
            if (!currentWindow.isFocused()) {
              this.debug("Window is not focused, bringing to front");
              needsActivation = true;
            }
            if (needsActivation) {
              if (!currentWindow.isAlwaysOnTop()) {
                currentWindow.setAlwaysOnTop(true);
                setTimeout(() => {
                  currentWindow.setAlwaysOnTop(false);
                  currentWindow.focus();
                  resolve();
                }, 200);
              } else {
                currentWindow.focus();
                setTimeout(resolve, 100);
              }
            } else {
              resolve();
            }
          } else {
            resolve();
          }
        } else {
          resolve();
        }
      } else {
        setTimeout(resolve, 50);
      }
    });
  }
  focusModalElement(modalElement) {
    const focusableElements = modalElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (focusableElements.length > 0) {
      const firstButton = modalElement.querySelector("button");
      const firstInput = modalElement.querySelector("input, textarea");
      let targetElement = null;
      if (firstButton) {
        targetElement = firstButton;
        this.debug("Focusing first button in modal");
      } else if (firstInput) {
        targetElement = firstInput;
        this.debug("Focusing first input in modal");
      } else {
        targetElement = focusableElements[0];
        this.debug("Focusing first focusable element in modal");
      }
      if (targetElement) {
        this.focusWithRetry(targetElement, 3);
      }
    } else {
      modalElement.setAttribute("tabindex", "-1");
      this.focusWithRetry(modalElement, 3);
      this.debug("Focusing modal container");
    }
    modalElement.scrollIntoView({
      behavior: "smooth",
      block: "center"
    });
  }
  async focusWithRetry(element, maxRetries) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        element.focus();
        if (document.activeElement === element) {
          this.debug(`Focus successful on attempt ${i + 1}`);
          return;
        }
        if (i < maxRetries - 1) {
          this.debug(`Focus attempt ${i + 1} failed, retrying...`);
          await this.delay(50);
        }
      } catch (error) {
        this.debug(`Focus attempt ${i + 1} error:`, error);
        if (i < maxRetries - 1) {
          await this.delay(50);
        }
      }
    }
    this.debug(`Failed to focus element after ${maxRetries} attempts`);
  }
  updateTranslations() {
    const lang = this.getLanguage();
    this.t = (key) => {
      return translations[lang][key] || translations["en"][key] || key;
    };
  }
  getLanguage() {
    if (this.settings.language === "zh") return "zh";
    if (this.settings.language === "en") return "en";
    const obsidianLang = this.app.vault?.config?.language;
    const systemLang = navigator.language.toLowerCase();
    if (obsidianLang?.includes("zh") || systemLang.includes("zh")) {
      return "zh";
    }
    return "en";
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateTranslations();
  }
  restartDetection() {
    if (this.modalObserver) {
      this.modalObserver.disconnect();
      this.modalObserver = null;
    }
    if (this.detectionTimer) {
      clearInterval(this.detectionTimer);
      this.detectionTimer = null;
    }
    this.setupModalDetection();
  }
};
var ReminderFocusSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: this.plugin.t("pluginName") });
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("language")).setDesc(this.plugin.t("languageDesc")).addDropdown(
      (dropdown) => dropdown.addOption("auto", this.plugin.t("auto")).addOption("zh", this.plugin.t("chinese")).addOption("en", this.plugin.t("english")).setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
        this.display();
        new import_obsidian.Notice(this.plugin.t("settingsSaved"));
      })
    );
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("enableFocus")).setDesc(this.plugin.t("enableFocusDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFocus).onChange(async (value) => {
        this.plugin.settings.enableFocus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("focusInterval")).setDesc(this.plugin.t("focusIntervalDesc")).addText(
      (text) => text.setPlaceholder("60").setValue(String(this.plugin.settings.focusInterval)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 1) {
          this.plugin.settings.focusInterval = num;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian.Notice(this.plugin.t("invalidInterval"));
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("detectionInterval")).setDesc(this.plugin.t("detectionIntervalDesc")).addText(
      (text) => text.setPlaceholder("1000").setValue(String(this.plugin.settings.detectionInterval)).onChange(async (value) => {
        const num = parseInt(value);
        if (!isNaN(num) && num >= 100) {
          this.plugin.settings.detectionInterval = num;
          await this.plugin.saveSettings();
          this.plugin.restartDetection();
        } else {
          new import_obsidian.Notice(this.plugin.t("invalidDetectionInterval"));
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName(this.plugin.t("debugMode")).setDesc(this.plugin.t("debugModeDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
